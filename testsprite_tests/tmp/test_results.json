[
  {
    "projectId": "cbcd922b-cfc8-43cc-958b-451481b3efb7",
    "testId": "345ed883-4bae-4d44-86f0-80bf63b20401",
    "userId": "d4589468-e0b1-706b-c272-5a409e30201c",
    "title": "TC001-get_public_plans_should_return_list_of_public_plans",
    "description": "Verify that the GET /api/public/plans endpoint returns a list of all public subscription plans available for users with a 200 status code.",
    "code": "import requests\n\ndef test_get_public_plans_should_return_list_of_public_plans():\n    base_url = \"http://localhost:3000\"\n    url = f\"{base_url}/api/public/plans\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=30)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to GET /api/public/plans failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n\n    try:\n        response_json = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # If response is a dict, try to get the list from 'plans' key or verify the dict contains a list value\n    if isinstance(response_json, list):\n        plans_list = response_json\n    elif isinstance(response_json, dict) and \"plans\" in response_json and isinstance(response_json[\"plans\"], list):\n        plans_list = response_json[\"plans\"]\n    else:\n        assert False, \"Response JSON does not contain list of plans\"\n\n    assert isinstance(plans_list, list), \"Plans is not a list\"\n\n\ntest_get_public_plans_should_return_list_of_public_plans()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-28T01:30:17.084Z",
    "modified": "2025-11-28T01:31:06.598Z"
  },
  {
    "projectId": "cbcd922b-cfc8-43cc-958b-451481b3efb7",
    "testId": "690286e2-7596-434d-8c1e-5b62ddccb0d1",
    "userId": "d4589468-e0b1-706b-c272-5a409e30201c",
    "title": "TC002-get_admin_dashboard_should_return_statistics_for_authorized_users",
    "description": "Verify that the GET /api/admin/dashboard endpoint returns dashboard statistics including user counts, financial metrics, and recent feedbacks only for authenticated users with ADMIN role, and returns 401 for unauthorized access.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nADMIN_DASHBOARD_ENDPOINT = \"/api/admin/dashboard\"\nTIMEOUT = 30\n\n# Placeholder token for an authenticated user with ADMIN role\n# Replace with a valid token for actual tests\nADMIN_AUTH_TOKEN = \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.ADMIN_ROLE_VALID_TOKEN\"\n\ndef test_get_admin_dashboard_should_return_statistics_for_authorized_users():\n    headers_auth = {\n        \"Authorization\": ADMIN_AUTH_TOKEN,\n        \"Accept\": \"application/json\"\n    }\n\n    headers_no_auth = {\n        \"Accept\": \"application/json\"\n    }\n    # Test unauthorized access returns 401\n    response_unauth = requests.get(\n        f\"{BASE_URL}{ADMIN_DASHBOARD_ENDPOINT}\",\n        headers=headers_no_auth,\n        timeout=TIMEOUT\n    )\n    assert response_unauth.status_code == 401, (\n        f\"Expected status code 401 for unauthorized access, got {response_unauth.status_code}\"\n    )\n\n    # Test authorized access returns 200 and dashboard stats\n    response_auth = requests.get(\n        f\"{BASE_URL}{ADMIN_DASHBOARD_ENDPOINT}\",\n        headers=headers_auth,\n        timeout=TIMEOUT\n    )\n    assert response_auth.status_code == 200, (\n        f\"Expected status code 200 for authorized access, got {response_auth.status_code}\"\n    )\n\n    json_data = response_auth.json()\n    # Validate presence of expected keys in the dashboard statistics\n    expected_keys = [\n        \"userCounts\",\n        \"financialMetrics\",\n        \"recentFeedbacks\"\n    ]\n    for key in expected_keys:\n        assert key in json_data, f\"Missing expected key '{key}' in dashboard response\"\n\n    # Further validation of userCounts\n    user_counts = json_data.get(\"userCounts\")\n    assert isinstance(user_counts, dict), \"userCounts should be a dictionary\"\n    assert \"totalUsers\" in user_counts and isinstance(user_counts[\"totalUsers\"], int), \"userCounts.totalUsers should be an integer\"\n    assert \"activeUsers\" in user_counts and isinstance(user_counts[\"activeUsers\"], int), \"userCounts.activeUsers should be an integer\"\n\n    # Further validation of financialMetrics\n    financial_metrics = json_data.get(\"financialMetrics\")\n    assert isinstance(financial_metrics, dict), \"financialMetrics should be a dictionary\"\n    financial_fields = [\"totalIncome\", \"totalExpenses\", \"totalInvestments\", \"totalTithes\"]\n    for field in financial_fields:\n        assert field in financial_metrics and isinstance(financial_metrics[field], (int, float)), f\"financialMetrics.{field} should be a number\"\n\n    # Further validation of recentFeedbacks\n    recent_feedbacks = json_data.get(\"recentFeedbacks\")\n    assert isinstance(recent_feedbacks, list), \"recentFeedbacks should be a list\"\n    for feedback in recent_feedbacks:\n        assert isinstance(feedback, dict), \"Each feedback item should be a dictionary\"\n        assert \"id\" in feedback, \"Each feedback should have an 'id'\"\n        assert \"message\" in feedback, \"Each feedback should have a 'message'\"\n        assert \"createdAt\" in feedback, \"Each feedback should have 'createdAt' timestamp\"\n\ntest_get_admin_dashboard_should_return_statistics_for_authorized_users()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 72, in <module>\n  File \"<string>\", line 36, in test_get_admin_dashboard_should_return_statistics_for_authorized_users\nAssertionError: Expected status code 200 for authorized access, got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-28T01:30:17.090Z",
    "modified": "2025-11-28T01:30:50.149Z"
  },
  {
    "projectId": "cbcd922b-cfc8-43cc-958b-451481b3efb7",
    "testId": "282256e2-af1c-49ee-989f-45e4bef502cd",
    "userId": "d4589468-e0b1-706b-c272-5a409e30201c",
    "title": "TC003-admin_plans_crud_operations_should_work_correctly",
    "description": "Verify that the /api/admin/plans endpoints support creating, retrieving, updating, and deleting subscription plans with proper authentication and return appropriate status codes.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Authentication token: replace with valid token for the admin user with proper permissions\nADMIN_AUTH_TOKEN = \"your_admin_auth_token_here\"\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {ADMIN_AUTH_TOKEN}\",\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\ndef admin_plans_crud_operations_should_work_correctly():\n    plan_id = None\n    created_plan_id = None\n    url_plans = f\"{BASE_URL}/api/admin/plans\"\n\n    # Sample new plan data for creation\n    new_plan_data = {\n        \"name\": f\"Test Plan {uuid.uuid4()}\",\n        \"description\": \"Plan created during automated test\",\n        \"price\": 1999,  # price in cents or integer value as expected\n        \"currency\": \"USD\",\n        \"interval\": \"month\",\n        \"trial_period_days\": 14,\n        \"features\": [\"feature1\", \"feature2\"],\n        \"active\": True\n    }\n\n    # Updated plan data for update\n    updated_plan_data = {\n        \"name\": \"Updated \" + new_plan_data[\"name\"],\n        \"description\": \"Updated plan description\",\n        \"price\": 2999,\n        \"currency\": \"USD\",\n        \"interval\": \"month\",\n        \"trial_period_days\": 7,\n        \"features\": [\"feature1\", \"feature2\", \"feature3\"],\n        \"active\": False\n    }\n\n    try:\n        # 1. Create a new plan via POST\n        resp_create = requests.post(url_plans, json=new_plan_data, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_create.status_code == 201 or resp_create.status_code == 200, f\"Create plan failed with status {resp_create.status_code}\"\n        create_json = resp_create.json()\n        assert \"id\" in create_json, \"Response missing 'id' in create plan\"\n        created_plan_id = create_json[\"id\"]\n\n        # 2. Retrieve the list of all plans via GET, confirm created plan exists\n        resp_list = requests.get(url_plans, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_list.status_code == 200, f\"List plans failed with status {resp_list.status_code}\"\n        plans_list = resp_list.json()\n        assert any(p.get(\"id\") == created_plan_id for p in plans_list), \"Created plan not found in plans list\"\n\n        # 3. Update the created plan via PUT\n        url_plan_id = f\"{url_plans}/{created_plan_id}\"\n        resp_update = requests.put(url_plan_id, json=updated_plan_data, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_update.status_code == 200, f\"Update plan failed with status {resp_update.status_code}\"\n        updated_json = resp_update.json()\n        # Check updated values\n        assert updated_json.get(\"name\") == updated_plan_data[\"name\"], \"Plan name not updated correctly\"\n        assert updated_json.get(\"description\") == updated_plan_data[\"description\"], \"Plan description not updated correctly\"\n        assert updated_json.get(\"price\") == updated_plan_data[\"price\"], \"Plan price not updated correctly\"\n        assert updated_json.get(\"trial_period_days\") == updated_plan_data[\"trial_period_days\"], \"Plan trial_period_days not updated correctly\"\n        assert updated_json.get(\"active\") == updated_plan_data[\"active\"], \"Plan active flag not updated correctly\"\n\n        # 4. Delete the created plan via DELETE\n        resp_delete = requests.delete(url_plan_id, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_delete.status_code == 204 or resp_delete.status_code == 200, f\"Delete plan failed with status {resp_delete.status_code}\"\n\n        # 5. Verify the plan was deleted: GET the list and confirm absence\n        resp_list_after_delete = requests.get(url_plans, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_list_after_delete.status_code == 200, f\"List plans after delete failed with status {resp_list_after_delete.status_code}\"\n        plans_list_after_delete = resp_list_after_delete.json()\n        assert all(p.get(\"id\") != created_plan_id for p in plans_list_after_delete), \"Deleted plan still present in plans list\"\n\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\n    except AssertionError:\n        # If the created plan still exists during a failure, attempt to delete to clean up\n        if created_plan_id:\n            try:\n                requests.delete(f\"{url_plans}/{created_plan_id}\", headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n        raise\n\n# call the test function\nadmin_plans_crud_operations_should_work_correctly()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 94, in <module>\n  File \"<string>\", line 48, in admin_plans_crud_operations_should_work_correctly\nAssertionError: Create plan failed with status 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-28T01:30:17.097Z",
    "modified": "2025-11-28T01:31:13.076Z"
  },
  {
    "projectId": "cbcd922b-cfc8-43cc-958b-451481b3efb7",
    "testId": "e04d131a-3c91-4e7a-a968-d4ee3bdee6bf",
    "userId": "d4589468-e0b1-706b-c272-5a409e30201c",
    "title": "TC004-refresh_plan_pricing_should_update_pricing_from_clerk",
    "description": "Verify that the POST /api/admin/plans/refresh-pricing endpoint refreshes the subscription plan pricing data from Clerk and returns success status for authenticated admin users.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nREFRESH_PRICING_ENDPOINT = \"/api/admin/plans/refresh-pricing\"\nTIMEOUT = 30\n\n# This token should be an authenticated admin user's Clerk token\n# Replace the value below with a valid token for actual testing\nADMIN_AUTH_TOKEN = \"Bearer YOUR_ADMIN_AUTH_TOKEN\"\n\ndef test_refresh_plan_pricing_should_update_pricing_from_clerk():\n    url = BASE_URL + REFRESH_PRICING_ENDPOINT\n    headers = {\n        \"Authorization\": ADMIN_AUTH_TOKEN,\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n\n    try:\n        response = requests.post(url, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to refresh plan pricing failed with exception: {e}\"\n\n    # The API should return success status for authenticated admin users\n    assert response.status_code == 200, (\n        f\"Expected status code 200, got {response.status_code}. Response text: {response.text}\"\n    )\n\n    # Optional: Further validate response content if known, e.g. JSON success flag\n    try:\n        json_data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Assuming the response includes success indication (e.g., a 'success' boolean or similar)\n    assert \"success\" in json_data, \"Response JSON does not contain 'success' field\"\n    assert json_data[\"success\"] is True, f\"Expected 'success' to be True, got {json_data['success']}\"\n\ntest_refresh_plan_pricing_should_update_pricing_from_clerk()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 25, in test_refresh_plan_pricing_should_update_pricing_from_clerk\nAssertionError: Expected status code 200, got 401. Response text: Unauthorized\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-28T01:30:17.102Z",
    "modified": "2025-11-28T01:30:59.697Z"
  },
  {
    "projectId": "cbcd922b-cfc8-43cc-958b-451481b3efb7",
    "testId": "70f2054c-5d55-48b1-9b8d-4a269e8f42c1",
    "userId": "d4589468-e0b1-706b-c272-5a409e30201c",
    "title": "TC005-admin_users_management_should_handle_user_operations",
    "description": "Verify that the /api/admin/users endpoints support listing users, getting user details, updating user information, activating users, inviting new users, and syncing users with Clerk with proper authentication and correct responses.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Replace with valid admin Bearer token from Clerk authentication\nAUTH_TOKEN = \"Bearer YOUR_ADMIN_AUTH_TOKEN\"\n\nHEADERS = {\n    \"Authorization\": AUTH_TOKEN,\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\",\n}\n\ndef admin_users_management_should_handle_user_operations():\n    created_user_id = None\n    invited_user_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    invited_user_id = None\n\n    try:\n        # 1. List users GET /api/admin/users\n        resp = requests.get(f\"{BASE_URL}/api/admin/users\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"List users failed: {resp.text}\"\n        users_list = resp.json()\n        assert isinstance(users_list, list), \"Users list should be an array\"\n\n        # 2. Invite new user POST /api/admin/users/invite\n        invite_payload = {\n            \"email\": invited_user_email,\n            \"permissionLevel\": \"USER\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/admin/users/invite\", headers=HEADERS, json=invite_payload, timeout=TIMEOUT)\n        assert resp.status_code == 200 or resp.status_code == 201, f\"Invite user failed: {resp.text}\"\n        invited_response = resp.json()\n        invited_user_id = invited_response.get(\"id\")\n        assert invited_user_id, \"Invited user id should be present\"\n\n        # 3. Sync users with Clerk POST /api/admin/users/sync\n        resp = requests.post(f\"{BASE_URL}/api/admin/users/sync\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Sync users failed: {resp.text}\"\n        sync_resp = resp.json()\n        assert isinstance(sync_resp, dict), \"Sync response should be a dict\"\n\n        # 4. Get user details GET /api/admin/users/{id}\n        # Use an existing user id from users list or fallback to invited user id\n        target_user_id = users_list[0].get(\"id\") if users_list else invited_user_id\n        assert target_user_id, \"No user available for detail fetch\"\n        resp = requests.get(f\"{BASE_URL}/api/admin/users/{target_user_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Get user details failed: {resp.text}\"\n        user_details = resp.json()\n\n        # 5. Update user PATCH /api/admin/users/{id}\n        update_payload = {}\n        # Attempt to toggle 'isActive' or update 'name' if present in user_details\n        if \"name\" in user_details:\n            new_name = user_details[\"name\"] + \" Updated\"\n            update_payload = {\"name\": new_name}\n        else:\n            # If no 'name', add a dummy field for patch test (assuming email can't be changed)\n            update_payload = {}\n\n        if update_payload:\n            resp = requests.patch(f\"{BASE_URL}/api/admin/users/{target_user_id}\", headers=HEADERS, json=update_payload, timeout=TIMEOUT)\n            assert resp.status_code == 200, f\"Update user failed: {resp.text}\"\n            updated_user = resp.json()\n            for k, v in update_payload.items():\n                assert updated_user.get(k) == v, f\"User {k} not updated\"\n\n        # 6. Activate user POST /api/admin/users/{id}/activate\n        resp = requests.post(f\"{BASE_URL}/api/admin/users/{target_user_id}/activate\", headers=HEADERS, timeout=TIMEOUT)\n        # Activation may succeed (200) or be idempotent; accept 200 or 204\n        assert resp.status_code in (200, 204), f\"Activate user failed: {resp.text}\"\n\n    finally:\n        # Clean up: delete invited user if created\n        if invited_user_id:\n            requests.delete(f\"{BASE_URL}/api/admin/users/{invited_user_id}\", headers=HEADERS, timeout=TIMEOUT)\n\nadmin_users_management_should_handle_user_operations()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 80, in <module>\n  File \"<string>\", line 24, in admin_users_management_should_handle_user_operations\nAssertionError: List users failed: Unauthorized\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-28T01:30:17.107Z",
    "modified": "2025-11-28T01:31:13.079Z"
  },
  {
    "projectId": "cbcd922b-cfc8-43cc-958b-451481b3efb7",
    "testId": "bc7cae5a-abff-4bea-94fa-f4835ce3b3fc",
    "userId": "d4589468-e0b1-706b-c272-5a409e30201c",
    "title": "TC006-admin_settings_should_get_and_update_settings",
    "description": "Verify that the GET and PUT /api/admin/settings endpoints allow authenticated admin users to retrieve and update application settings correctly.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nAPI_PATH = \"/api/admin/settings\"\nFULL_URL = BASE_URL + API_PATH\nTIMEOUT = 30\n\n# Replace this with a valid admin auth token for Clerk authentication\nADMIN_AUTH_TOKEN = \"YOUR_ADMIN_AUTH_TOKEN\"\n\nheaders = {\n    \"Authorization\": f\"Bearer {ADMIN_AUTH_TOKEN}\",\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\ndef admin_settings_should_get_and_update_settings():\n    # Step 1: GET current settings\n    response_get = requests.get(FULL_URL, headers=headers, timeout=TIMEOUT)\n    assert response_get.status_code == 200, f\"GET /api/admin/settings failed with status {response_get.status_code}\"\n    try:\n        settings = response_get.json()\n    except Exception:\n        assert False, \"GET /api/admin/settings did not return valid JSON\"\n\n    # Validate key exists in settings object, could be empty or contain keys\n    assert isinstance(settings, dict), \"Settings response is not a JSON object\"\n\n    # Prepare update payload: Toggle or add a test property \"testUpdateFlag\"\n    # If property exists and is a boolean, toggle it, else set to True\n    test_flag = settings.get(\"testUpdateFlag\", False)\n    new_flag_value = not test_flag if isinstance(test_flag, bool) else True\n\n    updated_settings = dict(settings)\n    updated_settings[\"testUpdateFlag\"] = new_flag_value\n\n    # Step 2: PUT update settings\n    response_put = requests.put(FULL_URL, headers=headers, json=updated_settings, timeout=TIMEOUT)\n    assert response_put.status_code == 200, f\"PUT /api/admin/settings failed with status {response_put.status_code}\"\n    try:\n        updated_response = response_put.json()\n    except Exception:\n        assert False, \"PUT /api/admin/settings did not return valid JSON\"\n\n    # Validate the updated value matches what was sent\n    assert isinstance(updated_response, dict), \"Updated settings response is not a JSON object\"\n    assert updated_response.get(\"testUpdateFlag\") == new_flag_value, \"Updated setting value does not match expected\"\n\n    # Step 3: GET settings again to verify update persisted\n    response_get_after = requests.get(FULL_URL, headers=headers, timeout=TIMEOUT)\n    assert response_get_after.status_code == 200, f\"GET after update failed with status {response_get_after.status_code}\"\n    try:\n        settings_after = response_get_after.json()\n    except Exception:\n        assert False, \"GET after update did not return valid JSON\"\n\n    assert settings_after.get(\"testUpdateFlag\") == new_flag_value, \"Persisted setting value does not match updated value\"\n\n\nadmin_settings_should_get_and_update_settings()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 60, in <module>\n  File \"<string>\", line 20, in admin_settings_should_get_and_update_settings\nAssertionError: GET /api/admin/settings failed with status 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-28T01:30:17.113Z",
    "modified": "2025-11-28T01:31:02.278Z"
  },
  {
    "projectId": "cbcd922b-cfc8-43cc-958b-451481b3efb7",
    "testId": "9ce286a4-fbb6-4f21-9e35-4781d0f1813c",
    "userId": "d4589468-e0b1-706b-c272-5a409e30201c",
    "title": "TC007-admin_usage_should_return_usage_statistics",
    "description": "Verify that the GET /api/admin/usage endpoint returns usage statistics and analytics data only for authenticated admin users.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nADMIN_USAGE_ENDPOINT = \"/api/admin/usage\"\nTIMEOUT = 30\n\n# Replace this with a valid token for an authenticated admin user.\nADMIN_AUTH_TOKEN = \"REPLACE_WITH_VALID_ADMIN_JWT_TOKEN_OR_BEARER_TOKEN\"\n\ndef test_admin_usage_should_return_usage_statistics():\n    headers = {\n        \"Authorization\": f\"Bearer {ADMIN_AUTH_TOKEN}\",\n        \"Accept\": \"application/json\"\n    }\n    url = BASE_URL + ADMIN_USAGE_ENDPOINT\n\n    # Test successful access by authenticated admin user\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed with exception: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError as e:\n        assert False, f\"Response is not valid JSON: {e}\"\n\n    # Validate that usage statistics expected fields exist (generic check)\n    assert isinstance(data, dict), \"Response JSON is not an object/dictionary\"\n    expected_keys = [\"usageStatistics\", \"analytics\", \"metrics\"]\n    assert any(key in data for key in expected_keys), f\"Response JSON does not contain any expected keys: {expected_keys}\"\n\n    # Test access denied for unauthenticated user (no auth header)\n    try:\n        resp_no_auth = requests.get(url, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request without auth to {url} failed with exception: {e}\"\n\n    assert resp_no_auth.status_code in (401, 403), f\"Expected 401 or 403 without auth, got {resp_no_auth.status_code}\"\n\n    # Test access denied for authenticated non-admin user\n    NON_ADMIN_AUTH_TOKEN = \"REPLACE_WITH_VALID_NON_ADMIN_JWT_TOKEN_OR_BEARER_TOKEN\"\n    headers_non_admin = {\n        \"Authorization\": f\"Bearer {NON_ADMIN_AUTH_TOKEN}\",\n        \"Accept\": \"application/json\"\n    }\n    try:\n        resp_non_admin = requests.get(url, headers=headers_non_admin, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request with non-admin auth to {url} failed with exception: {e}\"\n    assert resp_non_admin.status_code in (401, 403), f\"Expected 401 or 403 for non-admin user, got {resp_non_admin.status_code}\"\n\ntest_admin_usage_should_return_usage_statistics()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 54, in <module>\n  File \"<string>\", line 23, in test_admin_usage_should_return_usage_statistics\nAssertionError: Expected status code 200, got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-28T01:30:17.119Z",
    "modified": "2025-11-28T01:31:08.810Z"
  },
  {
    "projectId": "cbcd922b-cfc8-43cc-958b-451481b3efb7",
    "testId": "709e2351-f747-4d99-9cfa-a1fbdb90810e",
    "userId": "d4589468-e0b1-706b-c272-5a409e30201c",
    "title": "TC008-admin_storage_should_return_storage_items",
    "description": "Verify that the GET /api/admin/storage endpoint returns storage management data for uploaded files only for authenticated admin users.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nADMIN_STORAGE_ENDPOINT = \"/api/admin/storage\"\nTIMEOUT = 30\n\n# Provide a valid admin authentication token here\nADMIN_AUTH_TOKEN = \"your_admin_auth_token_here\"  \n\ndef admin_storage_should_return_storage_items():\n    headers = {\n        \"Authorization\": f\"Bearer {ADMIN_AUTH_TOKEN}\",\n        \"Accept\": \"application/json\"\n    }\n    url = f\"{BASE_URL}{ADMIN_STORAGE_ENDPOINT}\"\n\n    # Test authorized access (authenticated admin user)\n    response = requests.get(url, headers=headers, timeout=TIMEOUT)\n    assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n    json_data = response.json()\n    assert isinstance(json_data, (list, dict)), \"Response JSON should be a list or dict representing storage items\"\n    # Optional: More specific assertions can be added here if schema is known\n\n    # Test unauthorized access (no or invalid token)\n    unauthorized_headers = {\n        \"Accept\": \"application/json\"\n    }\n    response_unauth = requests.get(url, headers=unauthorized_headers, timeout=TIMEOUT)\n    assert response_unauth.status_code in [401,403], f\"Expected 401/403 for unauthorized access, got {response_unauth.status_code}\"\n\nadmin_storage_should_return_storage_items()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 31, in <module>\n  File \"<string>\", line 19, in admin_storage_should_return_storage_items\nAssertionError: Expected status 200, got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-28T01:30:17.124Z",
    "modified": "2025-11-28T01:31:18.298Z"
  },
  {
    "projectId": "cbcd922b-cfc8-43cc-958b-451481b3efb7",
    "testId": "79c8135f-cd14-4756-b78d-9c5210eb9891",
    "userId": "d4589468-e0b1-706b-c272-5a409e30201c",
    "title": "TC009-clerk_plans_should_return_subscription_plans",
    "description": "Verify that the GET /api/admin/clerk/plans endpoint returns subscription plans fetched from Clerk for authenticated admin users.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nAPI_PATH = \"/api/admin/clerk/plans\"\nTIMEOUT = 30\n\n# NOTE: Replace 'YOUR_AUTH_TOKEN' below with a valid Clerk admin user token for authentication.\nAUTH_TOKEN = \"YOUR_AUTH_TOKEN\"\n\n\ndef test_clerk_plans_should_return_subscription_plans():\n    headers = {\n        \"Authorization\": f\"Bearer {AUTH_TOKEN}\",\n        \"Accept\": \"application/json\",\n    }\n\n    url = f\"{BASE_URL}{API_PATH}\"\n\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected 200 OK but got {response.status_code}\"\n\n    try:\n        plans = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert isinstance(plans, (list, dict)), \"Response JSON should be a list or dict of subscription plans\"\n\n    # Basic check: response must not be empty\n    assert plans, \"Subscription plans response is empty\"\n\n    # Additional checks can be added depending on the expected structure, e.g.:\n    if isinstance(plans, list):\n        for plan in plans:\n            assert isinstance(plan, dict), \"Each plan should be a dictionary\"\n            assert \"id\" in plan, \"Plan should have an 'id' key\"\n            assert \"name\" in plan, \"Plan should have a 'name' key\"\n\n    # No cleanup needed as this is a GET read operation\n\n\ntest_clerk_plans_should_return_subscription_plans()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 46, in <module>\n  File \"<string>\", line 24, in test_clerk_plans_should_return_subscription_plans\nAssertionError: Expected 200 OK but got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-28T01:30:17.129Z",
    "modified": "2025-11-28T01:31:14.472Z"
  },
  {
    "projectId": "cbcd922b-cfc8-43cc-958b-451481b3efb7",
    "testId": "fed2e033-1759-4477-89f1-6d169c174a64",
    "userId": "d4589468-e0b1-706b-c272-5a409e30201c",
    "title": "TC010-clerk_webhook_should_handle_authentication_events",
    "description": "Verify that the POST /api/webhooks/clerk endpoint correctly handles Clerk webhook events for user creation, update, and deletion with valid payloads.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nWEBHOOK_ENDPOINT = f\"{BASE_URL}/api/webhooks/clerk\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_clerk_webhook_should_handle_authentication_events():\n    # Define valid payloads for user creation, update, and deletion events.\n    events = [\n        {\n            \"type\": \"user.created\",\n            \"data\": {\n                \"id\": \"user_123\",\n                \"email_addresses\": [\"testuser_create@example.com\"],\n                \"first_name\": \"Test\",\n                \"last_name\": \"Create\"\n            }\n        },\n        {\n            \"type\": \"user.updated\",\n            \"data\": {\n                \"id\": \"user_123\",\n                \"email_addresses\": [\"testuser_update@example.com\"],\n                \"first_name\": \"TestUpdated\",\n                \"last_name\": \"Update\"\n            }\n        },\n        {\n            \"type\": \"user.deleted\",\n            \"data\": {\n                \"id\": \"user_123\"\n            }\n        }\n    ]\n\n    for event in events:\n        try:\n            response = requests.post(\n                WEBHOOK_ENDPOINT,\n                json=event,\n                headers=HEADERS,\n                timeout=TIMEOUT,\n            )\n        except requests.RequestException as e:\n            assert False, f\"Request failed: {e}\"\n\n        # The expected behavior is a 200 status for successful handling of the event\n        assert response.status_code == 200, f\"Unexpected status code: {response.status_code} for event type {event['type']}\"\n\n        # The response content may be empty or contain some acknowledgement; accept 2xx and JSON or empty response\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        if content_type.startswith(\"application/json\"):\n            try:\n                json_resp = response.json()\n                # Optionally check for presence of keys if known, else just confirm it's a dict\n                assert isinstance(json_resp, dict), \"Response JSON is not a dictionary\"\n            except ValueError:\n                assert False, \"Response indicated JSON but failed to parse\"\n        else:\n            # Allow empty or no content\n            assert response.text.strip() == \"\" or response.text, \"Unexpected non-JSON non-empty response\"\n\ntest_clerk_webhook_should_handle_authentication_events()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 49, in test_clerk_webhook_should_handle_authentication_events\nAssertionError: Unexpected status code: 400 for event type user.created\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-28T01:30:17.134Z",
    "modified": "2025-11-28T01:31:35.647Z"
  }
]
